---
title: "WGCNA"
author: "Elsa Brenner, Alexa Huzar, and Erica Sun"
date: "4/22/2021"
output: html_document
---

# Introduction

A recent study found that when algal symbiont cells (*Breviolum psygmophilum*) are in a coral host (*Oculina arbuscula*), they display a muted response to thermal stress compared to the host itself. This lead to several outstanding questions including whether corals are somehow protecting, or buffering their symbiont cells from stressful temperatures, or perhaps the symbiont cells were non-responsive to the temperatures tested. To answer these questions, *Breviolum psygmophilum* cells were isolated from the same population of coral host and exposed to the same pattern of thermal stress as the corals. Exposing the symbiont cells to the same thermal stress as the corals, but out of symbiosis, will help clarify what role coral hosts plays in the symbiont transcriptomic response to temperature stress. We are comparing differentially gene expression between cold and heat stress to determine what stress causing a stronger response. Additionally, we will compare what GO categories are up- or down-regulated in response to each stress to determine what pathways are activated or repressed. These results can then be compared to the results of the previous study to better understand if the corals are protecting their symbiont cells. 

WCGNA analysis incorporates trait data to determine what gene groupings are correlated with different traits. For our data, this allows us to confirm that differential gene expression is due to the different treatments and not due to differences in cell density or growth rate.

**R version** 

We used R version R-4.0.3 (Package versions listed below)

```{r, loadlib, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(WGCNA) #Version 1.70-3
library(impute) #Version 1.64.0
library(flashClust) #Version 1.01-2
library(DESeq2) #Version  1.30.1
library(pheatmap) #Version 1.0.12
```


# Data preparation
#### First, we must rename and filter our data to get the best results.

We read in our count data file that was created from the raw sequences. Row names were changed to match the row names of the GO term files to allow proper GO enrichment analysis later.  
```{r}
countData <- read.table("B_psygmophilum_counts.txt")
length(countData[,1])

names(countData)=c( "Control_1.1", "Control_1", "Control_2.1", "Control_2", "Control_3.1", "Control_3", "Control_4.1", "Control_4", "Cool_1", "Cool_2", "Cool_3", "Cool_4","Heat_1.1", "Heat_1", "Heat_2.1", "Heat_2", "Heat_3.1", "Heat_3", "Heat_4.1", "Heat_4")
row.names(countData)=sub("", "isogroup", rownames(countData))

treat=c( "Control", "Control", "Control", "Control", "Control", "Control", "Control", "Control", "Cool", "Cool", "Cool", "Cool","Heat", "Heat", "Heat", "Heat", "Heat", "Heat", "Heat", "Heat")
g=data.frame(treat)
colData<- g
```

#### We run the same DeSeq object as before but we filter out trash counts

We only kept contigs that with a baseMean <3 which gets rid of low counts that would be annoying
```{r, warning=FALSE, error=FALSE, message=FALSE}
dds<-DESeqDataSetFromMatrix(countData=countData, colData=colData, design=~ treat) 
dds<-DESeq(dds)
res<- results(dds)
res3<-res[res$baseMean>3, ]
dim(res) #28265
dim(res3) #15962
```
This filtered out about 12,000 contigs.

#### Make rlog data

We run an rlog transformation which is a normalization method important for later downstream analysis.
```{r}
rld <- rlogTransformation(dds, blind=TRUE, fitType="local")
rld_wg=(assay(rld))
nrow(rld_wg)
```

The above object still has the trash counts so we filter again as we did above.
```{r}
rldFiltered=(assay(rld))[(rownames((assay(rld))) %in% rownames(res3)),]
nrow(rldFiltered)
```

This data then gets written into a csv file so we can use the data in the WGCNA analysis
```{r, eval=FALSE}
write.csv( rldFiltered,file="Bpsy_wgcna_allgenes.csv",quote=F,row.names=T)
```

# WGCNA analysis 

#### Data input and cleaning

We read in the data file created above and rename the rows based on the isogroup names.
```{r}
options(stringsAsFactors=FALSE)
allowWGCNAThreads()

dat=read.csv("Bpsy_wgcna_allgenes.csv")
rownames(dat)<-dat$X
dat$X=NULL
names(dat)
nrow(dat)
```

Now we create a data frame to check for outliers. An output of TRUE indicates that there are no outlier genes.
```{r}
datExpr0 = as.data.frame(t(dat))
gsg = goodSamplesGenes(datExpr0, verbose = 3);
gsg$allOK
```
**We found no outliers!**

Now we read in the data file containing trait information. Traits are average cell count, average cells per mL, average cell growth rate, and thermal stress treatment.
```{r}
traitData= read.csv("Bpsy_Traits_Num.csv", row.names=1)
names(traitData)
```

This makes sure that the row names of our count data and the row names of our trait data are the same to ensure proper alignment of the datasets. This is required for proper anazlying of count data in terms of the traits. If the code returns TRUE, the files are properly aligned. 
```{r}
rownames(traitData)=rownames(datExpr0)
traitData$Sample= NULL 
datTraits=traitData

table(rownames(datTraits)==rownames(datExpr0))
```

Now we create a dendogram and trait heat map showing how linked the gene expression in each sample is. We calculate whole network connectivity and choose signed as we are interested in the direction of gene expression
```{r}
A=adjacency(t(datExpr0),type="signed") #default is unsigned, we want signed
k=as.numeric(apply(A,2,sum))-1
Z.k=scale(k)
thresholdZ.k=-2.5 # often -2.5
outlierColor=ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
traitColors=data.frame(numbers2colors(datTraits,signed=FALSE))
dimnames(traitColors)[[2]]=paste(names(datTraits))
datColors=data.frame(outlierC=outlierColor,traitColors)

plotDendroAndColors(sampleTree,groupLabels=names(datColors), colors=datColors,main="Sample dendrogram and trait heatmap")
```

Figure 2.1 Sample dendrogram and trait heatmap. The top half of the graph shows a dendrogram illustrating how related each sample is. The heatmap of the traits on the bottome half of the graph combined with the dendrogram show that samples are grouped most closely by what treatment they were exposed to. 


**we save this because it can take a lot to actually make this with large dataset**
```{r}
save(datExpr0, datTraits, file="Bpsy_Samples_Traits_ALL.RData")
```

# Network construction and module detection

#### First we figure out the proper soft-thresholding power
```{r, results='hide',warning=FALSE, error=FALSE, message=FALSE}
options(stringsAsFactors = FALSE)
allowWGCNAThreads() 
lnames = load(file="Bpsy_Samples_Traits_ALL.RData")

powers = c(seq(1,14,by=2), seq(15,30, by=0.5));
sft = pickSoftThreshold(datExpr0, powerVector = powers, networkType="signed", verbose = 2) 
```

Now we plot the results from above to determine what soft power we want to choose
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",ylim=c(0,1),
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
abline(h=0.90,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

Figure 2.2 Plots of scale free topology or mean connectivity versus soft threshold. Based on when both graphs start to plateau, a soft threshold power of 9 was chosen for the downstream analysis. 

#### Calculating similarity

After choosing a soft power, we calculate adjacency which can be translated into topological overlap matrix which is a separate measure of similarity. 
```{r, results='hide',warning=FALSE, error=FALSE, message=FALSE}
softPower=9
adjacency=adjacency(datExpr0, power=softPower,type="signed")
TOM= TOMsimilarity(adjacency,TOMType = "signed")
dissTOM= 1-TOM
```

```{r}
geneTree= flashClust(as.dist(dissTOM), method="average")
sizeGrWindow(10,6)
plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE,hang=0.04)
```

Figure 2.3 Gene clustering based on TOM dissimilarity. Based on the TOM calculations done above, genes are clustered based on their similarity which is displayed in this dendrogram. Each leaf is a gene and branches that are  grouped together densely are interconnected, highly co-expressed genes.


#### Module creation

**Now that we have dendrogram and TOM dissimilarity, we can use these to define modules**

We choose only large modules. We use a hybrid method of dynamic tree cutting that uses both the dendrogram and TOM dissimilairty as inputs to cut and merge modules.
```{r}
minModuleSize=90
dynamicMods= cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
table(dynamicMods)
```

These modules are assigned colors and graphed underneath the dendrogram. 
```{r}
dynamicColors= labels2colors(dynamicMods)
sizeGrWindow(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")
```

Figure 2.4 Dendrogram graphed with moduled membership. After dynamic tree cutting, the gene dendrogram is graphed with the module membership graphed underneath. 


We currently have a lot of modules that are likely closely related. Therefore, we want to merge together these modules of similar gene expression profiles to get the best correlations with the different traits. To do this we calculated eigengenes and then calculated the similarity between them. Modules are merged based on a cut value of 0.4 and the new larger modules are saved for additional analysis. 
```{r}
MEList= moduleEigengenes(datExpr0, colors= dynamicColors,softPower = 9)
MEs= MEList$eigengenes

MEDiss= 1-cor(MEs)

METree= flashClust(as.dist(MEDiss), method= "average")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "Network_bpsy_nomerge.RData")

lnames = load(file = "Network_bpsy_nomerge.RData")
#plot
sizeGrWindow(7,6)
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
MEDissThres= 0.4
abline(h=MEDissThres, col="red")

merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors= merge$colors
mergedMEs= merge$newMEs

plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
dev.off()

moduleColors= mergedColors
colorOrder= c("turquoise", standardColors(50))
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs

save(MEs, moduleLabels, moduleColors, geneTree, file= "Network_signed_0.6.RData")

```

Figure 2.5 Clustered module eigengenes. Eigengenes are plotted as a dendrogram with the names of the given modules at each branch. The red line is the cut point of 0.4. Modules below it are merged together based on their branching to create larger modules of similar expression patterns.


#### Relating modules to traits

**Now that we have modules of similar gene expression patterns, we want to see how they relate to the different sample traits**

For our dataset, we are testing whether gene expression differences between thermal stress treatment are actually do to those treatments or whether other variables like cell density caused the differential expression.










